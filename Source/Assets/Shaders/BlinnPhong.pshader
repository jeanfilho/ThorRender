#define FLAT_SHADING

struct PSInput
{
    float4 Position : SV_POSITION;
    float3 WorldPos : WORLDPOS;
    float3 Normal : NORMAL;
    float2 UV : TEXCOORD0;
};

cbuffer FrameData : register(b0)
{
    float4x4 ViewProj;
    float4x4 InvView;
    float3 LightDirection;
    float __Padding0;
    float3 LightColor;
    float __Padding1;
    float3 ViewPosition;
    float __Padding2;
};

cbuffer MaterialData : register(b2)
{
    float3 Albedo;
    float Metallic;
    float Roughness;
    float __Padding3[3];
};

#ifndef FLAT_SHADING
Texture2D AlbedoMap : register(t0);
Texture2D NormalMap : register(t1);
Texture2D MetallicMap : register(t2);
Texture2D RoughnessMap : register(t3);

SamplerState LinearSampler : register(s0);
#endif

float3 GetNormal(Texture2D normalMap, SamplerState samp, float2 uv, float3 geomNormal)
{
    float3 n = normalMap.Sample(samp, uv).xyz * 2.0f - 1.0f;
    // Assume tangent space = geometry normal for simplicity
    return normalize(n + geomNormal);
}

float4 main(PSInput input) : SV_TARGET
{
    // Normalize interpolated normal
    float3 n = normalize(input.Normal);
    
    // Light direction
    float3 l = normalize(LightDirection);
    
    // View direction
    float3 v = normalize(ViewPosition - input.WorldPos);
    
    // Calculate halfway vector
    float3 h = normalize(l + v);
    
    // Lighting calculations
    float NdotL = max(dot(n, l), 0.0f);
    float NdotH = max(dot(n, h), 0.0f);
    
    // Ambient
    float3 ambient = 0.05f * Albedo;
    
    // Diffuse (reduced by metallicness)
    float3 diffuse = NdotL * Albedo * LightColor * (1.0f - Metallic);
    
    // Specular
    float shininess = 32.0f * (1.0f - Roughness);
    float spec = pow(NdotH, shininess);
    float3 specular = spec * LightColor * lerp(0.04f, 1.0f, Metallic);
    
    float3 finalColor = ambient + diffuse + specular;
    return float4(finalColor, 1.0f);
}